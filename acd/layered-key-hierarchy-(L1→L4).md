# ACD-301: The Layered Key Hierarchy (L1 → L4)

| Status | Date | Document Type |
| :--- | :--- | :--- |
| **Active** | 2026-01-13 | Architecture Concept Design |

## Overview
The **Layered Key Hierarchy** is the core cryptographic data structure of the OpenKCM ecosystem. It implements a strict **Recursive Envelope Encryption** model designed to solve the tension between data sovereignty (customer control) and massive scale (provider performance).

Instead of using a single key to encrypt millions of records, OpenKCM organizes keys into a dependency tree. Each layer protects the confidentiality of the layer immediately below it. This ensures that the physical possession of encrypted data is useless without the entire chain of upstream keys remaining intact and unrevoked.

## The Hierarchy Definitions
OpenKCM standardizes four distinct levels of keys, each with a specific scope, lifecycle, and "Owner."

### L1: The Root of Trust (External)
* **Scope:** The entire Tenant or Organization.
* **Owner:** The Customer (Sovereign).
* **Storage:** External KMS (AWS KMS, Azure Key Vault, GCP KMS) or physical HSM.
* **Purpose:** This is the "Master Key" that wraps the L2. It never leaves the customer's controlled environment. The customer grants OpenKCM permission to `Unwrap` using this key, a permission they can revoke at any time.

### L2: The Tenant Key (Intermediate)
* **Scope:** A specific Tenant ID within the OpenKCM platform.
* **Owner:** OpenKCM Crypto Core (Managed on behalf of the Customer).
* **Storage:** Encrypted (wrapped by L1) in the Regional Internal Vault.
* **Purpose:** Provides the mathematical root of multi-tenancy. Even if the database is compromised, Tenant A's L2 key cannot be loaded without Tenant A's specific L1 key. This key wraps the L3 keys.

### L3: The Service / KEK (Intermediate)
* **Scope:** A logical domain, service, or compliance boundary (e.g., "Payments Service," "EU-Log-Archive").
* **Owner:** OpenKCM Crypto Core.
* **Storage:** Encrypted (wrapped by L2) in the Regional Internal Vault.
* **Purpose:** Acts as the **Key Encryption Key (KEK)** for high-volume operations. It is cached in memory by the Crypto Core (and pushed to the Crypto Edge) to wrap and unwrap L4 keys.

### L4: The Data Encryption Key / DEK (Leaf)
* **Scope:** A single record, file, object, or session.
* **Owner:** The Application / Workload.
* **Storage:** Ephemeral. It is generated by the **Crypto Edge**, used to encrypt the payload, and stored alongside the data (in the application database) encrypted (wrapped) by the L3 key.
* **Purpose:** High-speed bulk encryption. Millions of L4 keys can exist, all protected by a single L3 key.



## The Recursive Unsealing Flow
The system "boots" a tenant's context through a specific sequence of operations, moving from slow/external to fast/internal.

1.  **L1 Handshake:** The **OpenKCM Crypto Core** presents the encrypted L2 key material to the customer's external KMS. The KMS decrypts it (validating the customer's policy) and returns the plaintext L2 key into the Core's secure memory.
2.  **L2 Derivation:** The Core uses the plaintext L2 key to decrypt the specific **L3 Service Keys** required for the requested workloads.
3.  **L3 Distribution:** The plaintext L3 key is securely pushed (via mTLS) to the **Crypto Edge's** secure memory cache.
4.  **L4 Execution:** The **Crypto Edge** generates a plaintext L4 DEK for the application to use. It immediately encrypts a copy of this L4 DEK using the cached L3 key and returns the "Wrapped DEK" to the application for storage.

## Mathematical Siloing & Multi-Tenancy
This hierarchy enforces "Mathematical Isolation." In a traditional SaaS, a software bug might allow Tenant B to read Tenant A's data. In OpenKCM, even if the software fails, the cryptography holds.

* To decrypt Tenant A's data (L4), you need Tenant A's L3 key.
* To get Tenant A's L3 key, you need Tenant A's L2 key.
* To get Tenant A's L2 key, you must authenticate against Tenant A's external L1 KMS.
* Therefore, **Access to Data = Access to L1 Root**.

## Crypto-Shredding & Revocation
The hierarchy enables instant, verifiable data destruction (Crypto-Shredding) without needing to scrub magnetic disks.

* **Granular Shredding (L4 deletion):** Deleting a single L4 key makes a single record unreadable.
* **Domain Shredding (L3 deletion):** Rotating or deleting an L3 key renders millions of L4 keys (and their data) unreadable instantly.
* **Sovereign Revocation (L1 revocation):** If the customer disables their L1 key in their own AWS/Azure console, OpenKCM can no longer unwrap the L2 key. Once the cache expires (minutes), the entire tenant dataset is mathematically locked globally.

## Summary
This document defines the data structure that makes OpenKCM possible. The **L1 → L4 Hierarchy** allows the platform to balance two opposing requirements:
1.  **Sovereignty:** The customer retains ultimate control via the L1.
2.  **Speed:** The application enjoys local speed via the L4.
3.  **Efficiency:** The expensive remote calls to L1 happen rarely (only to unseal L2), while the cheap local calls happen frequently (L4 operations).